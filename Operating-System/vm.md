# 가상 메모리 Virtual Memory System

## 메모리
- 메모리란 프로그램과 프로그램 수행에 필요한 데이터 및 코드를 저장하는 장치
- 메모리는 크게 내부 기억장치인 `주기억장치`와 외부 기억장치인 `보조 기억장치`로 분류됨.
  - DRAM, CPU 안에 있는 레지스터와 캐쉬 등이 전자에 해당된다.
  - SSD, HDD가 후자에 해당됨

## 가상 메모리 등장 배경
초창기 컴퓨터에서 사용가능한 RAM의 용량이, 가장 큰 실행 애플리케이션의 주소 공간보다 커야 했음. 그러지 않을 경우 "메모리 부족" 오류에 의해 해당 어플리케이션을 실행할 수 없었음.  
  
이후 컴퓨터에서는 프로그래머가 **애플리케이션의 일부분만 기억장치에 올려 실행하도록 지정할** 수 있게 하는 **오버레이 기법**을 사용하여 메모리 부족 문제를 해결하고자 했음, 하지만 이 역시 전반적인 메모리 부족 문제를 해결할 수 없었고 오버레이를 사용하는 프로그램은 그렇지 않은 프로그램보다는 메모리를 덜 사용했었지만, 애초에 시스템이 프로그램을 위한 충분한 메모리를 갖추고 있지 않은 경우에는 결구 똑같은 메모리 부족 오류가 발생했음.  
  
여기에서 더 발전한 `가상 메모리 기법`은 애플리케이션을 실행하는 데 얼마나 많은 메모리가 필요한지 집중하지 않고, 대신 애플리케이션을 실행하는 데 최소한 얼마만큼의 메모리가 필요한가에 집중하여 문제를 해결하고자 함.
- 이렇게 접근하는 방식이 가능한 이유는, 메모리 접근은 순차적이고 지역화 되어있기 때문.
- 그렇다면 이렇게 애플리케이션의 일부분만 메모리에 올려진다면, 메모리에 올라가지 않는 나머지는 어디에 위치해야할까? -> 정답은 보조 기억장치, 즉 디스크
- 가상 메모리의 핵심은 `보조 기억 장치`

<br>

## 가상 메모리란
> 가상 메모리는 메모리가 실제 메모리보다 많아 보이게 하는 기술로, 어떤 프로세스가 실행될 때 메모리에 해당 프로세스 전체가 올라가지 않더라도 ㅣㄹ행이 가능하다는 점에 착안하여 고안되었음.

- 애플리케이션이 실행될 때, 실행에 필요한 일부분만 메모리에 올라가며 애플리케이션의 나머지는 디스크에 남게 됨. 즉, 디스크가 RAM의 보조기억장치처럼 작동하는 것임.
  - 결국 빠르고 작은 기억장치 RAM을 크고 느린 기억장치 디스크와 병합하여, 하나의 크고 빠른 기억장치(가상 메모리)처럼 동작하게 하는 것임.
- 가상 메모리를 구현하기 위해서는 컴퓨터가 특수 메모리 관리 하드웨어를 갖추고 있어야만 함, -> 바로 `MMU` (Memory Management Unit)

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbMHw35%2Fbtq5gwPeRPj%2FqZQ20xnWN3mIFoKPHDazh0%2Fimg.jpg)
- MMU는 **가상 주소를 물리 주소로 변환하고, 메모리를 보호**하는 기능을 수행한다.
- MMU를 사용하게 되면, CPU가 각 메모리에 접근하기 이전에 메모리 주소 번역 작업이 수행됨.
- 그러나 메모리를 일일이 가상 주소에서 물리적 주소로 번역하게 되면 작업 부하가 높아지므로, MMU는 RAM을 여러 부분 (페이지, pages)로 나누어 각 페이지를 하나의 독립적 항목으로 처리함.
- 페이지 및 주소 번역 정보를 기억하는 작업이 가상 메모리를 구현하는 데 있어 결정적인 절차임.

<br>

## 요구 페이징 demand paging
요구 페이징은 CPU가 요청할 때 프로세스의 데이터를 메모리에 올리는 것을 의미함. 즉, 처음부터 모든 데이터를 메모리로 적재하지는 않음.

## 페이지 폴트 page faults
페이지 폴트란 어떤 페이지에 접근하려고 했을 때 해당 페이지가 실제 물리 메모리에 부재할 때 뜨는 인터럽트이며, 페이지 플트가 발생하면 운영체제가 이를 해결한 뒤 다시 동일한 명령을 수행하는 식을 동작함.

- 어떤 프로그램이 자신의 주소 공간에는 존재하지만 시스템의 램에는 현재 존재하지 않는 데이터 코드에 접근을 시도할 경우 발생하는 현상을 의미함.
- 페이지 폴트가 발생하면 운영체제는 그 데이터를 메모리로 가져와서, 마치 페이지 폴트가 전혀 발생하지 않은 것 처럼 프로그램이 계속적으로 작동하게 해줌.
- 이러한 페이지 폴트가 자주 일어날수록 운영체제의 성능이 많이 저하되기 때문에 페이지 폴트가 일어나지 않도록 하는 것이 중요함. 페이지 폴트를 최소화하기 위한 방법으로는 **페이지 교체 정첵**이 있음
  - 메모리가 꽉 차 있을 때 기존 페이지 중 하나를 물리 메모리에서 저장 매체로 내리고, 새로운 페이지를 방금 비워진 해당 물리 메모리 공간에 올림, 이때 기존 페이지 중 어떤 것을 내리면 좋을지에 대한 알고리즘을 짠 것이 바로 페이지 교체 알고리즘


## TLB Translation Lookaside Buffer, 페이지 정보 캐쉬
가상 메모리 주소를 물리적 주소로 **변환하는 속도를 높이기 위해 사용하는 캐시**, 최근에 일어난 가상 메모리와 물리 주소의 변환 테이블을 저장해둠 CPU가 가상 주소를 가지고 메모리에 접근하려고 할때 우선은 TLB에 접근하여 가상 주소에 해당되는 무릴 주소를 찾고, 만약 TLB에 매핑이 존재하지 않는다면 MMU가 페이지 테이블에서 해당되는 물리 주소로 변환한 후 메모리에 접근하게 됨

